defmodule Ash.Filter do
  @moduledoc """
  A filter expression in Ash.

  The way we represent filters may be strange, but its important to have it structured,
  as merging and checking filter subsets are used all through ash for things like
  authorization. The `ands` of a filter are not subject to its `ors`. The `not` of a filter
  is also *not* subject to its `ors`.
  For instance, if a filter `A` has two `ands`, `B` and `C` and two `ors`, `D` and `E`, and
  a `not` of F, the expression as can be represented as `(A or D or E) and NOT F and B and C`.

  The filters `attributes` and `relationships`, *are* subject to the `ors` of that filter.

  `<and_statements> AND NOT <not_statement> AND (<one_of_or_statements> OR <attributes + relationships>)

  This probably needs to be refactored into something more representative of its behavior,
  like a series of nested boolean expression structs w/ a reference to the attribute/relationship
  it references. Maybe. This would be similar to Ecto's `BooleanExpr` structs.
  """
  defstruct [
    :api,
    :resource,
    :not,
    ands: [],
    ors: [],
    attributes: %{},
    relationships: %{},
    requests: [],
    path: [],
    errors: [],
    impossible?: false
  ]

  alias Ash.Engine
  alias Ash.Engine.Request
  alias Ash.Filter.Merge

  @type t :: %__MODULE__{
          api: Ash.api(),
          resource: Ash.resource(),
          ors: list(%__MODULE__{} | nil),
          not: %__MODULE__{} | nil,
          attributes: Keyword.t(),
          relationships: Map.t(),
          path: list(atom),
          impossible?: boolean,
          errors: list(String.t()),
          requests: list(Request.t())
        }

  @predicates %{
    not_eq: Ash.Filter.NotEq,
    not_in: Ash.Filter.NotIn,
    eq: Ash.Filter.Eq,
    in: Ash.Filter.In,
    and: Ash.Filter.And,
    or: Ash.Filter.Or
  }

  @spec parse(
          Ash.resource(),
          Keyword.t(),
          Ash.api(),
          relationship_path :: list(atom)
        ) :: t()
  @doc """
  Parse a filter from a filter expression

  The only rason to pass `api` would be if you intend to leverage
  any engine requests that would be generated by this filter.
  """
  def parse(resource, filter, api, path \\ [])

  def parse(resource, [], api, _),
    do: %__MODULE__{
      api: api,
      resource: resource
    }

  def parse(_resource, %__MODULE__{} = filter, _, _) do
    filter
  end

  def parse(resource, filter, api, path) do
    if Keyword.keyword?(filter) do
      if Keyword.get(filter, :__struct__) == __MODULE__ do
        raise "WHAT THE FUCK"
      end
    end

    parsed_filter = do_parse(filter, %Ash.Filter{resource: resource, api: api, path: path})

    source =
      case path do
        [] -> "filter"
        path -> "related #{Enum.join(path, ".")} filter"
      end

    if path == [] do
      parsed_filter
    else
      query =
        api
        |> Ash.Query.new(resource)
        |> Ash.Query.filter(parsed_filter)

      request =
        Request.new(
          resource: resource,
          api: api,
          query: query,
          path: [:filter, path],
          data:
            Request.resolve(
              [[:filter, path, :query]],
              fn %{filter: %{^path => %{query: query}}} ->
                data_layer_query = Ash.DataLayer.resource_to_query(resource)

                case Ash.DataLayer.filter(data_layer_query, query.filter, resource) do
                  {:ok, filtered_query} ->
                    Ash.DataLayer.run_query(filtered_query, resource)

                  {:error, error} ->
                    {:error, error}
                end
              end
            ),
          action: Ash.primary_action!(resource, :read),
          relationship: path,
          name: source
        )

      add_request(
        parsed_filter,
        request
      )
    end
  end

  def optional_paths(filter) do
    filter
    |> do_optional_paths()
    |> Enum.uniq()
  end

  defp do_optional_paths(%{relationships: relationships, requests: requests, ors: ors})
       when relationships == %{} and ors in [[], nil] do
    Enum.map(requests, fn request ->
      request.path
    end)
  end

  defp do_optional_paths(%{ors: [first | rest]} = filter) do
    do_optional_paths(first) ++ do_optional_paths(%{filter | ors: rest})
  end

  defp do_optional_paths(%{relationships: relationships} = filter) when is_map(relationships) do
    relationship_paths =
      Enum.flat_map(relationships, fn {_, value} ->
        do_optional_paths(value)
      end)

    relationship_paths ++ do_optional_paths(%{filter | relationships: %{}})
  end

  def request_filter_for_fetch(filter, data) do
    filter
    |> optional_paths()
    |> paths_and_data(data)
    |> most_specific_paths()
    |> Enum.reduce(filter, fn {path, %{data: related_data}}, filter ->
      [:filter, relationship_path] = path

      filter
      |> add_records_to_relationship_filter(
        relationship_path,
        List.wrap(related_data)
      )
      |> lift_impossibility()
    end)
  end

  defp most_specific_paths(paths_and_data) do
    Enum.reject(paths_and_data, fn {path, _} ->
      Enum.any?(paths_and_data, &path_is_more_specific?(path, &1))
    end)
  end

  # I don't think this is a possibility
  defp path_is_more_specific?([], []), do: false
  defp path_is_more_specific?(_, []), do: true
  # first element of the search matches first element of candidate
  defp path_is_more_specific?([part | rest], [part | candidate_rest]) do
    path_is_more_specific?(rest, candidate_rest)
  end

  defp path_is_more_specific?(_, _), do: false

  defp paths_and_data(paths, data) do
    Enum.flat_map(paths, fn path ->
      case Engine.fetch_nested_value(data, path) do
        {:ok, related_data} -> [{path, related_data}]
        :error -> []
      end
    end)
  end

  def empty_filter?(filter) do
    filter.attributes == %{} and filter.relationships == %{} and filter.not == nil and
      filter.ors in [[], nil] and filter.ands in [[], nil]
  end

  defp add_records_to_relationship_filter(filter, [], records) do
    case Ash.Actions.PrimaryKeyHelpers.values_to_primary_key_filters(filter.resource, records) do
      {:error, _error} ->
        # TODO: We should get this error out somehow?
        filter

      {:ok, []} ->
        if filter.ors in [[], nil] do
          # TODO: We should probably include some kind of filter that *makes* it immediately impossible
          # that way, if the data layer doesn't check impossibility they will run the simpler query,
          # like for each pkey field say `[field: [in: []]]`
          %{filter | impossible?: true}
        else
          filter
        end

      {:ok, [single]} ->
        do_parse(single, filter)

      {:ok, many} ->
        do_parse([or: many], filter)
    end
  end

  defp add_records_to_relationship_filter(filter, [relationship | rest] = path, records) do
    filter
    |> Map.update!(:relationships, fn relationships ->
      case Map.fetch(relationships, relationship) do
        {:ok, related_filter} ->
          Map.put(
            relationships,
            relationship,
            add_records_to_relationship_filter(related_filter, rest, records)
          )

        :error ->
          relationships
      end
    end)
    |> Map.update!(:ors, fn ors ->
      Enum.map(ors, &add_records_to_relationship_filter(&1, path, records))
    end)
  end

  defp lift_impossibility(filter) do
    filter =
      filter
      |> Map.update!(:relationships, fn relationships ->
        Enum.reduce(relationships, relationships, fn {key, filter}, relationships ->
          Map.put(relationships, key, lift_impossibility(filter))
        end)
      end)
      |> Map.update!(:ands, fn ands ->
        Enum.map(ands, &lift_impossibility/1)
      end)
      |> Map.update!(:ors, fn ors ->
        Enum.map(ors, &lift_impossibility/1)
      end)

    with_related_impossibility =
      if Enum.any?(filter.relationships || %{}, fn {_, val} -> Map.get(val, :impossible?) end) do
        Map.put(filter, :impossible?, true)
      else
        filter
      end

    if Enum.any?(with_related_impossibility.ands, &Map.get(&1, :impossible?)) do
      Map.put(with_related_impossibility, :impossible?, true)
    else
      with_related_impossibility
    end
  end

  defp add_not_filter_info(filter) do
    case filter.not do
      nil ->
        filter

      not_filter ->
        filter
        |> add_request(not_filter.requests)
        |> add_error(not_filter.errors)
    end
  end

  def predicate_strict_subset_of?(attribute, %left_struct{} = left, right) do
    left_struct.strict_subset_of?(attribute, left, right)
  end

  def add_to_filter(filter, %__MODULE__{} = addition) do
    if addition.ors == [] do
      filter_with_attributes =
        Enum.reduce(addition.attributes, filter, fn {attribute, predicate}, filter ->
          Map.update!(filter, :attributes, fn attributes ->
            Map.update(attributes, attribute, predicate, &Merge.merge(&1, predicate))
          end)
        end)

      filter_with_relationships =
        Enum.reduce(addition.relationships, filter_with_attributes, fn {relationship,
                                                                        relationship_filter},
                                                                       filter ->
          Map.update!(filter, :relationships, fn relationships ->
            Map.update(
              relationships,
              relationship,
              relationship_filter,
              &add_to_filter(&1, relationship_filter)
            )
          end)
        end)

      %{filter_with_relationships | ands: addition.ands ++ filter.ands}
    else
      %{filter | ands: [addition | filter.ands]}
    end
    |> lift_impossibility()
    |> lift_if_empty()
    |> add_not_filter_info()
  end

  def add_to_filter(filter, additions) do
    do_parse(additions, filter)
  end

  defp do_parse(filter_statement, %{resource: resource} = filter) do
    Enum.reduce(filter_statement, filter, fn
      {key, value}, filter ->
        cond do
          key == :__impossible__ && value == true ->
            %{filter | impossible?: true}

          key == :and ->
            if Keyword.keyword?(value) do
              %{filter | ands: [parse(filter.resource, value, filter.api) | filter.ands]}
            else
              empty_filter = parse(filter.resource, [], filter.api)

              filter_with_ands = %{
                empty_filter
                | ands: Enum.map(value, &parse(filter.resource, &1, filter.api))
              }

              %{filter | ands: [filter_with_ands | filter.ands]}
            end

          key == :or ->
            if Keyword.keyword?(value) do
              %{filter | ors: [parse(filter.resource, value, filter.api) | filter.ors]}
            else
              [first_or | rest_ors] = Enum.map(value, &parse(filter.resource, &1, filter.api))

              or_filter =
                filter.resource
                |> parse(first_or, filter.api)
                |> Map.update!(:ors, &Kernel.++(&1, rest_ors))

              %{filter | ands: [or_filter | filter.ands]}
            end

          key == :not ->
            Map.update!(filter, :not, fn not_filter ->
              if not_filter do
                add_to_filter(not_filter, value)
              else
                parse(filter.resource, filter, filter.api)
              end
            end)

          attr = Ash.attribute(resource, key) ->
            add_attribute_filter(filter, attr, value)

          rel = Ash.relationship(resource, key) ->
            add_relationship_filter(filter, rel, value)

          true ->
            add_error(
              filter,
              "Attempted to filter on #{key} which is neither a relationship, nor a field of #{
                inspect(resource)
              }"
            )
        end
    end)
    |> lift_impossibility()
    |> lift_if_empty()
    |> add_not_filter_info()
  end

  defp lift_if_empty(%{
         ors: [],
         ands: [and_filter | rest],
         attributes: attrs,
         relationships: rels,
         not: nil,
         errors: errors
       })
       when attrs == %{} and rels == %{} do
    and_filter
    |> Map.update!(:ands, &Kernel.++(&1, rest))
    |> lift_if_empty()
    |> Map.update!(:errors, &Kernel.++(&1, errors))
  end

  defp lift_if_empty(%{
         ands: [],
         ors: [or_filter | rest],
         attributes: attrs,
         relationships: rels,
         not: nil,
         errors: errors
       })
       when attrs == %{} and rels == %{} do
    or_filter
    |> Map.update!(:ors, &Kernel.++(&1, rest))
    |> lift_if_empty()
    |> Map.update!(:errors, &Kernel.++(&1, errors))
  end

  defp lift_if_empty(filter) do
    filter
  end

  defp add_attribute_filter(filter, attr, value) do
    if Keyword.keyword?(value) do
      Enum.reduce(value, filter, fn
        {predicate_name, value}, filter ->
          do_add_attribute_filter(filter, attr, predicate_name, value)
      end)
    else
      add_attribute_filter(filter, attr, eq: value)
    end
  end

  defp do_add_attribute_filter(
         %{attributes: attributes, resource: resource} = filter,
         %{type: attr_type, name: attr_name},
         predicate_name,
         value
       ) do
    case parse_predicate(resource, predicate_name, attr_name, attr_type, value) do
      {:ok, predicate} ->
        new_attributes =
          Map.update(
            attributes,
            attr_name,
            predicate,
            &Merge.merge(&1, predicate)
          )

        %{filter | attributes: new_attributes}

      {:error, error} ->
        add_error(filter, error)
    end
  end

  def parse_predicates(resource, keyword, attr_name, attr_type) do
    Enum.reduce(keyword, {:ok, nil}, fn {predicate_name, value}, {:ok, existing_predicate} ->
      case parse_predicate(resource, predicate_name, attr_name, attr_type, value) do
        {:ok, predicate} ->
          if existing_predicate do
            {:ok, Merge.merge(existing_predicate, predicate)}
          else
            {:ok, predicate}
          end

        {:error, error} ->
          {:error, error}
      end
    end)
  end

  def count_of_clauses(nil), do: 0

  def count_of_clauses(filter) do
    relationship_clauses =
      filter.relationships
      |> Map.values()
      |> Enum.map(fn related_filter ->
        1 + count_of_clauses(related_filter)
      end)
      |> Enum.sum()

    or_clauses =
      filter.ors
      |> Kernel.||([])
      |> Enum.map(&count_of_clauses/1)
      |> Enum.sum()

    not_clauses = count_of_clauses(filter.not)

    and_clauses =
      filter.ands
      |> Enum.map(&count_of_clauses/1)
      |> Enum.sum()

    Enum.count(filter.attributes) + relationship_clauses + or_clauses + not_clauses + and_clauses
  end

  defp parse_predicate(resource, predicate_name, attr_name, attr_type, value) do
    data_layer = Ash.data_layer(resource)

    with {:predicate_type, {:ok, predicate_type}} <-
           {:predicate_type, Map.fetch(@predicates, predicate_name)},
         {:type_can?, _, true} <-
           {:type_can?, predicate_name,
            Ash.Type.supports_filter?(resource, attr_type, predicate_name, data_layer)},
         {:data_layer_can?, _, true} <-
           {:data_layer_can?, predicate_name,
            Ash.data_layer_can?(resource, {:filter, predicate_name})},
         {:predicate, _, {:ok, predicate}} <-
           {:predicate, attr_name, predicate_type.new(resource, attr_name, attr_type, value)} do
      {:ok, predicate}
    else
      {:predicate_type, :error} ->
        {:error, "No such filter type #{predicate_name}"}

      {:predicate, attr_name, {:error, error}} ->
        {:error, Map.put(error, :field, attr_name)}

      {:type_can?, predicate_name, false} ->
        {:error,
         "Cannot use filter type #{inspect(predicate_name)} on type #{inspect(attr_type)}."}

      {:data_layer_can?, predicate_name, false} ->
        {:error, "data layer not capable of provided filter: #{predicate_name}"}
    end
  end

  defp add_relationship_filter(
         %{relationships: relationships} = filter,
         %{destination: destination, name: name} = relationship,
         value
       ) do
    case parse_relationship_filter(value, relationship) do
      {:ok, provided_filter} ->
        related_filter = parse(destination, provided_filter, filter.api, [name | filter.path])

        new_relationships =
          Map.update(relationships, name, related_filter, &Merge.merge(&1, related_filter))

        filter
        |> Map.put(:relationships, new_relationships)
        |> add_relationship_compatibility_error(relationship)
        |> add_error(related_filter.errors)
        |> add_request(related_filter.requests)

      {:error, error} ->
        add_error(filter, error)
    end
  end

  defp parse_relationship_filter(value, %{destination: destination} = relationship) do
    cond do
      match?(%__MODULE__{}, value) ->
        {:ok, value}

      match?(%^destination{}, value) ->
        Ash.Actions.PrimaryKeyHelpers.value_to_primary_key_filter(destination, value)

      is_map(value) ->
        {:ok, Map.to_list(value)}

      Keyword.keyword?(value) ->
        {:ok, value}

      is_list(value) ->
        Enum.reduce_while(value, {:ok, []}, fn item, items ->
          case parse_relationship_filter(item, relationship) do
            {:ok, item_filter} -> {:cont, {:ok, [item_filter | items]}}
            {:error, error} -> {:halt, {:error, error}}
          end
        end)

      true ->
        Ash.Actions.PrimaryKeyHelpers.value_to_primary_key_filter(destination, value)
    end
  end

  defp add_relationship_compatibility_error(%{resource: resource} = filter, %{
         cardinality: cardinality,
         destination: destination,
         name: name
       }) do
    data_layer = Ash.data_layer(resource)

    cond do
      not data_layer.can?({:filter_related, cardinality}) ->
        add_error(
          filter,
          "Cannot filter on relationship #{name}: #{inspect(data_layer)} does not support it."
        )

      not (Ash.data_layer(destination) == data_layer) ->
        add_error(
          filter,
          "Cannot filter on related entites unless they share a data layer, for now."
        )

      true ->
        filter
    end
  end

  defp add_request(filter, requests)
       when is_list(requests),
       do: %{filter | requests: filter.requests ++ requests}

  defp add_request(%{requests: requests} = filter, request),
    do: %{filter | requests: [request | requests]}

  defp add_error(%{errors: errors} = filter, errors) when is_list(errors),
    do: %{filter | errors: filter.errors ++ errors}

  defp add_error(%{errors: errors} = filter, error), do: %{filter | errors: [error | errors]}
end

defimpl Inspect, for: Ash.Filter do
  import Inspect.Algebra
  import Ash.Filter.InspectHelpers

  defguardp is_empty(val) when is_nil(val) or val == [] or val == %{}

  def inspect(%Ash.Filter{not: not_filter} = filter, opts) when not is_nil(not_filter) do
    if root?(opts) do
      concat([
        "#Filter<not ",
        to_doc(not_filter, make_non_root(opts)),
        " and ",
        to_doc(%{filter | not: nil}, make_non_root(opts)),
        ">"
      ])
    else
      concat([
        "not ",
        to_doc(not_filter, make_non_root(opts)),
        " and ",
        to_doc(%{filter | not: nil}, make_non_root(opts))
      ])
    end
  end

  def inspect(
        %Ash.Filter{ors: ors, relationships: relationships, attributes: attributes, ands: ands},
        opts
      )
      when is_empty(ors) and is_empty(relationships) and is_empty(attributes) and is_empty(ands) do
    if root?(opts) do
      concat(["#Filter<", to_doc(nil, opts), ">"])
    else
      to_doc(nil, opts)
    end
  end

  def inspect(filter, opts) do
    rels = parse_relationships(filter, opts)
    attrs = parse_attributes(filter, opts)

    and_container =
      case attrs ++ rels do
        [] ->
          empty()

        [and_clause] ->
          and_clause

        and_clauses ->
          Inspect.Algebra.container_doc("(", and_clauses, ")", opts, fn term, _ -> term end,
            break: :flex,
            separator: " and"
          )
      end

    with_or_container =
      case Map.get(filter, :ors) do
        nil ->
          and_container

        [] ->
          and_container

        ors ->
          inspected_ors = Enum.map(ors, fn filter -> to_doc(filter, make_non_root(opts)) end)

          or_container =
            Inspect.Algebra.container_doc(
              "(",
              inspected_ors,
              ")",
              opts,
              fn term, _ -> term end,
              break: :strict,
              separator: " or "
            )

          if Enum.empty?(attrs) && Enum.empty?(rels) do
            or_container
          else
            concat(["(", and_container, " or ", or_container, ")"])
          end
      end

    all_container =
      case filter.ands do
        [] ->
          with_or_container

        ands ->
          docs = [with_or_container | Enum.map(ands, &Inspect.inspect(&1, make_non_root(opts)))]

          Inspect.Algebra.container_doc(
            "(",
            docs,
            ")",
            opts,
            fn term, _ -> term end,
            break: :strict,
            separator: " and "
          )
      end

    if root?(opts) do
      concat(["#Filter<", all_container, ">"])
    else
      all_container
    end
  end

  defp parse_relationships(%Ash.Filter{relationships: relationships}, _opts)
       when relationships == %{},
       do: []

  defp parse_relationships(filter, opts) do
    filter
    |> Map.fetch!(:relationships)
    |> Enum.map(fn {key, value} -> to_doc(value, add_to_path(opts, key)) end)
  end

  defp parse_attributes(%Ash.Filter{attributes: attributes}, _opts) when attributes == %{}, do: []

  defp parse_attributes(filter, opts) do
    filter
    |> Map.fetch!(:attributes)
    |> Enum.map(fn {key, value} -> to_doc(value, put_attr(opts, key)) end)
  end
end
